*- [CONVERTER] New INCLUDE file, with #DEFINEs
#INCLUDE zl08det.h

*- [CONVERTER] Parameter statement generated by Converter
*- [CONVERTER] Pass these values along to the new form
PARAMETERS trb,org,orgodl
dimension plncna(1,50)
LOCAL _aParm, _cparmstr, _nctr
DIMENSION _aParm[3]
_aParm[1] = [trb]
_aParm[2] = [org]
_aParm[3] = [orgodl]

_cparmstr = []

IF PARAMETERS() > 0
	_cparmstr = [WITH ]
	_cparmstr = _cparmstr + _aParm[1]
	FOR m._nctr = 2 TO PARAMETERS()
		_cparmstr = _cparmstr + [,] + _aParm[m._nctr]
	NEXT
ENDIF

*- [CONVERTER] Declare arrays
EXTERNAL ARRAY brdet
EXTERNAL ARRAY jm
EXTERNAL ARRAY plncna
EXTERNAL ARRAY potkol
EXTERNAL ARRAY prz
EXTERNAL ARRAY przops
EXTERNAL ARRAY trzkol

EXTERNAL PROC zl08det.scx

DO FORM "zl08det.scx" NAME _0130HTU2B LINKED &_cparmstr

*- [CONVERTER] Begin CLEANUP and other procedures from 2.x Form


PROCEDURE readdeac
	IF isediting
		ACTIVATE WINDOW 'zl08'
		WAIT WINDOW c_edits NOWAIT
	ENDIF
	IF !WVISIBLE(WOUTPUT())
		CLEAR READ
		RETURN .T.
	ENDIF
	RETURN .F.

PROCEDURE readact

	RELEASE WINDOW EXPO
	IF !isediting
		SELECT (m.wzalias)
		SHOW GETS
	ENDIF
	DO REFRESH
	RETURN

PROCEDURE wizerrorhandler
	* This very simple error handler is primarily intended
	* to trap for General field OLE errors which may occur
	* during editing from the MODIFY GENERAL window.
	WAIT WINDOW MESSAGE()
	RETURN


PROCEDURE printrec
	*DO zl08stmp.spr
	IF ekran=1
	REPORT FORM zl08stmp.frx PREVIEW
	ENDIF
	IF stampa=1
	REPORT FORM zl08stmp.frx TO PRINTER NOCONSOLE
	ENDIF
	RETURN


PROCEDURE btn_val
	PARAMETER m.btnname
	DO CASE
		CASE  m.btnname='TOP'
			brdet(1)=1
			brdet(2)=2
			brdet(3)=3
			WAIT WINDOW 'Pocetak' NOWAIT
			    
			
		CASE  m.btnname='PREV'
			
				if !(brdet(1)=1)
					brdet(1)=brdet(1)-1
					brdet(2)=brdet(2)-1
					brdet(3)=brdet(3)-1
				else
				WAIT WINDOW 'Pocetak' NOWAIT
							
			ENDIF
			    
		CASE  m.btnname='NEXT'
			if !(brdet(1)=47)
					brdet(1)=brdet(1)+1
					brdet(2)=brdet(2)+1
					brdet(3)=brdet(3)+1
					
				else
					WAIT WINDOW 'Kraj' NOWAIT
				ENDIF
				
		CASE  m.btnname='END'
			brdet(1)=47
			brdet(2)=48
			brdet(3)=49
			
			WAIT WINDOW 'Kraj' NOWAIT
			   
		CASE  m.btnname='LOCATE'
			DO zl08tr.spr
		CASE  m.btnname='ADD'  AND !isediting &&add record
			select trbdet
			brlin=0
			go top
	        scan for m.trbdet=trbdet.trb
		         brlin=trbdet.lin
	        endscan
			brdet(1)=brlin+1
			brdet(2)=brlin+2
			brdet(3)=brlin+3
			przdet1=prz(1,brdet(1))
			przdet2=prz(1,brdet(2))
			przdet3=prz(1,brdet(3))
			trzkold1=trzkol(1,brdet(1))
			trzkold2=trzkol(1,brdet(2))
			trzkold3=trzkol(1,brdet(3))
			potkold1=potkol(1,brdet(1))
			potkold2=potkol(1,brdet(2))
			potkold3=potkol(1,brdet(3))
			BRDET1=1
			BRDET2=1
			BRDET3=1
			isediting=.T.
			isadding=.T.
			=edithand('ADD')
			_CUROBJ=1
			DO REFRESH
			SHOW GETS
			RETURN
		CASE  m.btnname='EDIT'  AND !isediting &&edit record
			if !(brdet1=1 or brdet2=1 or brdet3=1)
				menjanje=.f.
				return
			endif
			IF EOF() OR BOF()
				WAIT WINDOW c_endfile NOWAIT
				RETURN
			ENDIF
			IF RLOCK()
				isediting=.T.
				_CUROBJ=1
				DO REFRESH
				RETURN
			ELSE
				WAIT WINDOW c_nolock
			ENDIF
		CASE m.btnname='EDIT'  AND isediting &&save record
			IF isadding
				=edithand('SAVE')
			ELSE
				m.uneo=lekari
				m.datun= DATE()
				m.stsslg= 2
				*GATHER MEMVAR MEMO
				prz(1,brdet(1))=przdet1
			prz(1,brdet(2))=przdet2
			prz(1,brdet(3))=przdet3
			trzkol(1,brdet(1))=trzkold1
			trzkol(1,brdet(2))=trzkold2
			trzkol(1,brdet(3))=trzkold3
			potkol(1,brdet(1))=potkold1
			potkol(1,brdet(2))=potkold2
			potkol(1,brdet(3))=potkold3

			
			if !empty(prz(1,brdet(1))) AND brdet1=1
			select trbdet
			go top
			locate for (brdet(1)=trbdet.lin and m.trbdet=trbdet.trb)
			if found()
			 	replace prz with prz(1,brdet(1)), trzkol with trzkol(1,brdet(1)), ;
			 	potkol with potkol(1,brdet(1)), plncna with plncna(1,brdet(1)), przops with ;
			 	przops(1,brdet(1)), jm with jm(1,brdet(1))
			endif
			endif
			if !empty(prz(1,brdet(2))) AND brdet2=1
			 	select trbdet
			go top
			locate for (brdet(2)=trbdet.lin and m.trbdet=trbdet.trb)
			if found()
			 	replace prz with prz(1,brdet(2)), trzkol with trzkol(1,brdet(2)), ;
			 	potkol with potkol(1,brdet(2)), plncna with plncna(1,brdet(2)), przops with ;
			 	przops(1,brdet(2)), jm with jm(1,brdet(2))
			endif
			endif
			
			if !empty(prz(1,brdet(3))) and brdet3=1
			 	select trbdet
			go top
			locate for (brdet(3)=trbdet.lin and m.trbdet=trbdet.trb)
			if found()
			 	replace prz with prz(1,brdet(3)), trzkol with trzkol(1,brdet(3)), ;
			 	potkol with potkol(1,brdet(3)), plncna with plncna(1,brdet(3)), przops with ;
			 	przops(1,brdet(3)), jm with jm(1,brdet(3))
			endif
			endif
			go top
		
			scan for m.trbdet=trbdet.trb
	
				prz(1,trbdet.lin)=trbdet.prz
				jm(1,trbdet.lin)=trbdet.jm
				trzkol(1,trbdet.lin)=trbdet.trzkol
				potkol(1,trbdet.lin)=trbdet.potkol
				plncna(1,trbdet.lin)=trbdet.plncna
				przops(1,trbdet.lin)=trbdet.przops
			endscan
			go top
				
	        show gets

			ENDIF
			BRDET1=0
			BRDET2=0
			BRDET3=0
			UNLOCK
			menjanje=.t.
			isediting=.F.
			isadding=.F.
			DO REFRESH
		CASE m.btnname='DELETE'  AND isediting 	&&cancel record
			IF isadding
				=edithand('CANCEL')
			ENDIF
			menjanje=.t.
			isediting=.F.
			isadding=.F.
			UNLOCK
			BRDET1=0
			BRDET2=0
			BRDET3=0
			go top
			WAIT WINDOW c_ecancel NOWAIT
			DO REFRESH
		CASE m.btnname='DELETE'
		if !(brdet1=1 or brdet2=1 or brdet3=1)
				menjanje=.f.
				BRISI=.T.
				return
			endif
			IF EOF() OR BOF()
				WAIT WINDOW c_endfile NOWAIT
				RETURN
			ENDIF
			IF fox_alert(c_delrec)
				if brdet1=1
					select trbdet
					go top
					locate for (m.trbdet=trbdet.trb and brdet(1)=trbdet.lin)
					delete
					pack dbf
					prz(1,brdet(1))=' '
					potkol(1,brdet(1))=0
					trzkol(1,brdet(1))=0
					przops(1,brdet(1))=' '
					plncna(1,brdet(1))=0
					jm(1,brdet(1))=' '
				endif
				if brdet2=1
					select trbdet
					go top
					locate for (m.trbdet=trbdet.trb and brdet(2)=trbdet.lin)
					delete
					pack dbf
					prz(1,brdet(2))=' '
					jm(1,brdet(2))=' '
					potkol(1,brdet(2))=0
					trzkol(1,brdet(2))=0
					przops(1,brdet(2))=' '
					plncna(1,brdet(2))=0
				endif
				if brdet3=1
					select trbdet
					go top
					locate for (m.trbdet=trbdet.trb and brdet(3)=trbdet.lin)
					delete
					pack dbf
					prz(1,brdet(3))=' '
					jm(1,brdet(3))=' '
					potkol(1,brdet(3))=0
					trzkol(1,brdet(3))=0
					przops(1,brdet(3))=' '
					plncna(1,brdet(3))=0
				endif
				IF EOF()
					WAIT WINDOW c_endfile NOWAIT
					GO BOTTOM
				ENDIF
			ENDIF
			brdet1=0
			brdet2=0
			brdet3=0
			menjanje=.t.
			BRISI=.F.
		CASE m.btnname='PRINT'
		 	select orgglv
			set order to tag org
		 	select trbzgl
			DO printrec
			PRINTFLG=1
			RETURN
		CASE m.btnname='EXIT'
			m.bailout=.T.	&&this is needed if used with FoxApp
			CLEAR READ
			RETURN
	ENDCASE
	*SCATTER MEMVAR MEMO
			przdet1=prz(1,brdet(1))
			przdet2=prz(1,brdet(2))
			przdet3=prz(1,brdet(3))
			trzkold1=trzkol(1,brdet(1))
			trzkold2=trzkol(1,brdet(2))
			trzkold3=trzkol(1,brdet(3))
			potkold1=potkol(1,brdet(1))
			potkold2=potkol(1,brdet(2))
			potkold3=potkol(1,brdet(3))
		*select orgglv
		*go top
	    *locate for m.org=orgglv.org
	    *m.orgops=orgglv.ops
	    *go top
	    *locate for m.orgodl=orgglv.org
	    *m.orgops1=orgglv.ops
		*select trbzgl
		SHOW GETS
	RETURN


PROCEDURE REFRESH
	DO CASE
		CASE m.isreadonly AND RECCOUNT()=0
			SHOW GETS DISABLE
			SHOW GET exit_btn ENABLE
		CASE m.isreadonly
			SHOW GET add_btn DISABLE
			SHOW GET del_btn DISABLE
			SHOW GET edit_btn DISABLE
		CASE (RECCOUNT()=0 OR EOF()) AND !m.isediting
		if printflg=0
			SHOW GETS DISABLE
			SHOW GET add_btn ENABLE
			SHOW GET exit_btn ENABLE
		endif
		CASE m.isediting
			SHOW GET find_drop DISABLE
			SHOW GET top_btn DISABLE
			SHOW GET prev_btn DISABLE
			SHOW GET loc_btn DISABLE
			SHOW GET next_btn DISABLE
			SHOW GET end_btn DISABLE
			SHOW GET add_btn DISABLE
			SHOW GET prnt_btn DISABLE
			SHOW GET exit_btn DISABLE
			SHOW GET edit_btn,1 PROMPT "\<Potvrda"
			SHOW GET del_btn,1 PROMPT "\<Storno"
			ON KEY LABEL ESCAPE DO btn_val WITH 'DELETE'
			IF !isadding
				SHOW GET m.trb DISABLE
			ENDIF
			printflg=0
			RETURN
		OTHERWISE
			SHOW GET edit_btn,1 PROMPT "\<Menjaj"
			SHOW GET del_btn,1 PROMPT "\<Bri{i"
			SHOW GETS ENABLE
	ENDCASE
	IF m.is2table
		SHOW GET add_btn DISABLE
	ENDIF
	ON KEY LABEL ESCAPE
	RETURN


PROCEDURE edithand
	PARAMETER m.paction
	* procedure handles edits
	DO CASE
		CASE m.paction = 'ADD'
			SCATTER MEMVAR MEMO BLANK
		CASE m.paction = 'SAVE'
			m.uneo=lekari
			m.datun= DATE()
			m.stsslg= 1
			*
			prz(1,brdet(1))=przdet1
			prz(1,brdet(2))=przdet2
			prz(1,brdet(3))=przdet3
			trzkol(1,brdet(1))=trzkold1
			trzkol(1,brdet(2))=trzkold2
			trzkol(1,brdet(3))=trzkold3
			potkol(1,brdet(1))=potkold1
			potkol(1,brdet(2))=potkold2
			potkol(1,brdet(3))=potkold3

			
			if !empty(prz(1,brdet(1)))
			 	insert into trbdet (trb, prz, trzkol, potkol, plncna, lin, przops, jm) values ;
			 	(m.trbdet, prz(1,brdet(1)), trzkol(1,brdet(1)), potkol(1,brdet(1)), ;
			 	plncna(1,brdet(1)), brdet(1), przops(1,brdet(1)), jm(1,brdet(1)))
			endif
			
			if !empty(prz(1,brdet(2)))
			 	insert into trbdet (trb, prz, trzkol, potkol, plncna, lin, przops, jm) values ;
			 	(m.trbdet, prz(1,brdet(2)), trzkol(1,brdet(2)), potkol(1,brdet(2)), ;
			 	plncna(1,brdet(2)), brdet(2), przops(1,brdet(2)), jm(1,brdet(2)))
			endif
			
			if !empty(prz(1,brdet(3)))
			 	insert into trbdet (trb, prz, trzkol, potkol, plncna, lin, przops, jm) values ;
			 	(m.trbdet, prz(1,brdet(3)), trzkol(1,brdet(3)), potkol(1,brdet(3)), ;
			 	plncna(1,brdet(3)), brdet(3), przops(1,brdet(3)), jm(1,brdet(3)))
			endif
			go top
		
			scan for m.trbdet=trbdet.trb
	
				prz(1,trbdet.lin)=trbdet.prz
				jm(1,trbdet.lin)=trbdet.jm
				trzkol(1,trbdet.lin)=trbdet.trzkol
				potkol(1,trbdet.lin)=trbdet.potkol
				plncna(1,trbdet.lin)=trbdet.plncna
				przops(1,trbdet.lin)=trbdet.przops
			endscan
			go top
			BRDET1=0
			BRDET2=0
			BRDET3=0
			
	        show gets

			*
			
			
			CASE m.paction = 'CANCEL'
			select trbdet
			go top
		
			scan for m.trbdet=trbdet.trb
	
				prz(1,trbdet.lin)=trbdet.prz
				jm(1,trbdet.lin)=trbdet.jm
				trzkol(1,trbdet.lin)=trbdet.trzkol
				potkol(1,trbdet.lin)=trbdet.potkol
				plncna(1,trbdet.lin)=trbdet.plncna
				przops(1,trbdet.lin)=trbdet.przops
			endscan
			przops(1,brdet(1))=' '
			przops(1,brdet(2))=' '
			przops(1,brdet(3))=' '
			jm(1,brdet(1))=' '
			jm(1,brdet(2))=' '
			jm(1,brdet(3))=' '
			plncna(1,brdet(1))=' '
			plncna(1,brdet(2))=' '
			plncna(1,brdet(3))=' '
			go top
			BRDET1=0
			BRDET2=0
			BRDET3=0
	        show gets
			* nothing here
	ENDCASE
	RETURN

PROCEDURE fox_alert
	PARAMETER wzalrtmess
	PRIVATE alrtbtn
	m.alrtbtn=2
	DEFINE WINDOW _qec1ij2t7 AT 0,0 SIZE 8,50 ;
		FONT  "Times_lat", 12 STYLE 'B' ;
		FLOAT NOCLOSE NOMINIMIZE DOUBLE TITLE WTITLE()
	MOVE WINDOW _qec1ij2t7 CENTER
	ACTIVATE WINDOW _qec1ij2t7 NOSHOW
	@ 2,(50-TXTWIDTH(wzalrtmess))/2 SAY wzalrtmess;
		FONT "Times_lat", 12 STYLE "B"
	@ 6,18 GET m.alrtbtn ;
		PICTURE "@*HT \<DA;\?\!\<NE" ;
		SIZE 1.769,8.667,1.333 ;
		FONT "Times_lat", 9 STYLE "B"
	ACTIVATE WINDOW _qec1ij2t7
	READ CYCLE MODAL
	RELEASE WINDOW _qec1ij2t7
	RETURN m.alrtbtn=1


PROCEDURE pdialog
	DEFINE WINDOW _qjn12zbvh ;
		AT  0.000, 0.000  ;
		SIZE 13.231,54.800 ;
		FONT "Times_lat", 12 ;
		FLOAT NOCLOSE MINIMIZE SYSTEM
	MOVE WINDOW _qjn12zbvh CENTER
	ACTIVATE WINDOW _qjn12zbvh NOSHOW
	@ 2.846,33.600 SAY "Iznos:"  ;
		FONT "Times_lat", 12;
		STYLE "BT"
	@ 2.846,4.800 SAY "[tampa:"  ;
		FONT "Times_lat", 12 ;
		STYLE "BT"
	@ 4.692,7.200 GET m.p_recs ;
		PICTURE "@*RVN \<Teku}i slog;\<Svi slogovi" ;
		SIZE 1.308,18.500,0.308 ;
		DEFAULT 1 ;
		FONT "Times_lat", 12 ;
		STYLE "BT"
	@ 4.692,36.000 GET m.p_output ;
		PICTURE "@*RVN \<[tampa;\<Prikaz" ;
		SIZE 1.308,12.000,0.308 ;
		DEFAULT 1 ;
		FONT "Times_lat", 12 ;
		STYLE "BT"
	@ 10.154,16.600 GET m.prnt_btn ;
		PICTURE "@*HT [\<tampa;\<Poni{ti" ;
		SIZE 1.769,8.667,0.667 ;
		DEFAULT 1 ;
		FONT "Times_lat", 12;
		STYLE "B"
	ACTIVATE WINDOW _qjn12zbvh
	READ CYCLE MODAL
	RELEASE WINDOW _qjn12zbvh
	RETURN


PROCEDURE loc_dlog
	PRIVATE gfields,i
	*DEFINE WINDOW wzlocate FROM 1,1 TO 20,40;
	*	SYSTEM GROW  FONT "Times_Lat",8
	DEFINE WINDOW wzlocate FROM 0,0 TO WLROW('zl08')-0.5,SCOLS()  ;
		FONT "Times_Lat",8
	*	MOVE WINDOW wzlocate CENTER
	m.gfields=SET('FIELDS',2)
	IF !EMPTY(RELATION(1))
		SET FIELDS ON
		IF m.gfields # 'GLOBAL'
			SET FIELDS global
		ENDIF
		IF EMPTY(fldlist())
			m.i=1
			DO WHILE !EMPTY(objvar(m.i))
				IF ATC('M.',objvar(m.i))=0
					SET FIELDS TO (objvar(m.i))
				ENDIF
				m.i = m.i + 1
			ENDDO
		ENDIF
	ENDIF
	BROWSE WINDOW wzlocate NOEDIT NODELETE ;
		NOMENU
	SET FIELDS &gfields
	SET FIELDS OFF
	RELEASE WINDOW wzlocate
	RETURN



*- [CONVERTER] End CLEANUP and other procedures from 2.x Form
